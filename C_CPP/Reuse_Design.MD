코드 구현할 떄는 항상 재사용할 것을 염두에 두고 디자인, 구현

### **재사용 철학**
 - 작성은 한 번, 사용은 여러 번
 - 무슨 수를 쓰더라도 코드 중복은 피한다.
 - 같은 일을 반복하지 않는다.

### **재사용 디자인 방법**
디자인 조건
**1. 범용성 ( 너무 특화되지 않는다. )**
**2. 사용하기 쉬워야 한다.**

디자인 과정
**1. 코드의 구조를 잘 구성**
=> 클래스 계층 구성 방식, 템플릿 사용 여부, 서브시스템 나누는 방식
**2. 진입점(인터페이스)를 디자인**

### **추상화 방법**
자주 나오지만 인터페이스와 구현을 명확하게 분리해야 함

**구현 세부 사항을 클라이언트에 드러내지 않는다.**
특정 조작을 위해 사용하는 Handle 정보를 활용하는 경우,
이 또한 내부 구현을 드러내지 않도록 불투명(Opaque)클래스로 구현
=> 내부 데이터 멤버를 직접 접근하지 못하게 or 게터나 세터로 간접 접근

어떤 결정을 내릴 떄마다 추상화 원칙을 따르는지 확인

### **재사용에 최적화된 코드 구조화**
**서로 관련 없거나 구분되는 개념은 합치지 않는다.**
=> 응집도(cohesion) 높이기 = **단일책임성원칙** = Single Responsibility Principle, SRP
ex. 랜덤 생성기 != XML 파서
약간씩 변경해서 사용하려면 각 기능은 구분되어야 좋음

**프로그램을 서브시스템 단위로 논리적으로 나누기**
=> 결합도(Coupling)를 낮추기 
ex. 네트워크 게임 = 네트워킹 + GUI 분리

**클래스 계층을 사용해서 논리적으로 나누기**
서브시스템 외에 클래스 관점에서도 서로 관련 없는 개념이 엮이지 않도록 해야함
![image](https://user-images.githubusercontent.com/85000118/137124364-6f6f8e49-6ee3-460d-9bf1-0bbe83aece8e.png)
특화된 파생 클래스와 그를 대표하는 베이스 클래스를 따로 정의해야함

위에는 종류가 1가지라 괜찮지만 종류가 많아질 수록 복잡해짐

![image](https://user-images.githubusercontent.com/85000118/137124632-50607f30-e32e-490f-a815-0a1718b19dbc.png)

그럴 때는 믹스인 클래스로 자율주행 관련 알고리즘을 분리하여 작성한다.

자주 얘기하는 내용이지만,
관련 없는 개념은 잘 분리해야 함 + 최대한 그 클래스가 객체의 특성을 잘 담아 낼 수 있도록 디자인

**집합 관계를 사용해 논리적으로 나누기**
집합 관계 = has - a 관계 (상속 관계가 아닌, 가지고 있는(사용하는) 관계)
ex.) Family를 Tree 구조로 구현하지 않고, Tree클래스를 포함하게 함
=> 즉 has-a는 해당 클래스의 사용자 측면

**사용자 인터페이스에 대한 종속성 제거하기**
데이터 관리 라이브러리는 조작, 인터페이스를 분리해야 함
=> 특정 한 인터페이스에 종속되면 안됨
ex.) 데이터 관리 라이브러리 내부에서 cout을 사용하면 GUI에서는 사용 불가, 메시지 박스 표현 등

### **제네릭 데이터 구조와 알고리즘 템플릿 구현하기**
템플릿 이용하면 제네릭 구조체를 타입 or 클래스 형태로 생성 가능
=> 한 코드를 원하는 타입에 맞춰 적용 가능
ex.) vector<template> => 원하는 타입이나 구조체에 대한 배열 생성 가능

데이터 구조 및 알고리즘 구현 시, 특화된 형태 X, 범용적 디자인 O

**템플릿이 다른 제네릭 프로그래밍 테크닉보다 나은 이유**
1. C의 void* => 타입 세이프 하지 않음 + void*로 캐스팅해야 사용 가능
2. 데이터 구조를 특정 클래스에 맞게 정의(다형성 이용하여 파생 클래스로써 데이터 구조 저장) = 자바가 사용하는 방식
=> 타입 세이프하지 않음 - 객체 제거 시에 캐스팅했던 타입을 알아야하고 다운캐스팅 해야 함(하위 클래스로 캐스팅)

템플릿은 타입에 안전, 인스턴스가 다른 타입 저장하려 하면 컴파일 에러 발생

**템플릿 단점**
 - 문법이 복잡함
 - 동형 데이터 구조만 지원 ( 같은 타입의 객체만 저장 )
=> C++17부터는 동형성 제약을 표준에 따라 우회하는 방법 제공 (std::variant, std::any)

### **템플릿과 상속**
둘 중 어느것을 사용해야할 지 고민일 때 팁
 **동일한 기능 다양한 타입 = 템플릿**
=> 모든 타입에 동일한 기능 제공하는 정렬 등 (특정 타입 다르게하는 특화 템플릿도 있음)

**구체적인 타입마다 동작을 다르게 제공 = 상속**
=> 우선순위 큐나 큐는 비슷하지만 다른 동작

### **적절한 검사기능 + 안전장치 제공**
안전한 코드를 위한 스타일 2가지 ( 성격이 정반대 )
**1. 계약에 따른 디자인(design by contract)**
=> 사용자가 해야할 일, 구현한 클래스나 함수가 제공하는 것을 명시
=> 3가지 관점 사전조건, 사후조건, 불변조건

사전조건(선행) : 함수나 메서드 호출 전, 클라이언트 코드에서 반드시 만족해야 할 것
사후조건(후행) : 함수나 메서드 호출 후, 만족해야할 것
불변조건 : 항상 만족해야 할 조건

보통 표준 라이브러리에 사용됨
ex.) vector의 at은 경곗값 검사를 라이브러리에서 해주는데 배열 표기법 []를 쓸지 at을 쓸지는 판단하여 선택

**2. 함수나 클래스를 최대한 안전하게 디자인**
사용 코드에 에러 검사를 수행하게 디자인 ( ex. 잘못된 입력은 에러를 리턴 )
앞의 vector at 또한, 입력이 잘못되면 exception을 throw함
=> 최대한 안전하게 오류를 검출하고 처리하는 방식으로 디자인


### **확장성을 고려한 디자인**
클래스는 상속 확장에는 개방적이면서. 수정에는 폐쇄적일 수 있게 디자인
= 개방/폐쇄 원칙( Open/Closed Principle, OCP )

ex. 그리기 클래스가 있다고 가정,
=> 그릴 모양을 추가할 때마다, 그리기 클래스를 수정하고, 인자로 받으면 유지보수 불편
=> 각 모양은 Shape 클래스를 상속 받고, 그 안의 가상 함수를 오버라이드하여 어떻게 그릴지 추가된 모양만 구현
=> 그리기 클래스는 존재하는 shape들에 대해서 해당 객체가 가진 그리기 함수를 호출

위 예시처럼 수정하면, Render는 손댈 필요 없고, 확장도 용이함 ( 상속받고, 오버라이드 하기만 하면 됨 )


### **사용성 높은 인터페이스 디자인**
인터페이스가 훌륭해야 코드를 쉽게 재사용할 수 있음

### **인터페이스를 사용하기 쉽게 디자인하기
최대한 간결하고 직관적으로 사용하게

**익숙한 방식 따르기**
익숙한 표준 방식을 따르면, 파악하기 쉽고 쉽게 적응하고 잘못 사용 가능성도 낮음
ex. ) 생성자와 소멸자를 별도의 함수로 빼놓으면 타인이 사용하기 힘듦
=> 사용자 입장에서 상식에 맞는지, 충분히 예상 가능한지 따져보기

C++ 연산자 오버로딩(operator overloading) 기능을 제공함
연산자 오버로딩 이용하여, 익숙한 덧셈 뺄셈, cout 출력 연산자 << 등을 이용할 수 있다.
=> 남용하지말고 직관적인 해석이 가능한 구현을하면 좋다.

**필요한 기능 빼먹지 않기**
당연한 이야기
간혹 포함시켜야 할지 불분명한 기능은 모든 경우를 따져가며 생각해봐야 함

둘쨰로, 최대한 많은 기능을 구현하며, 최종 결과가 아닌 내용을 클라이언트에게 떠넘기면 안된다.

**군더더기 없는 인터페이스 제공**
쓸데 없는 기능을 많이 넣으면 산만하여 사용법 파악이 힘들어짐
=> 간결하고 깔끔하게 ( 꼭 필요한 기능은 포함 )
=> 작을수록 유지보수도 편함 

**문서와 주석 제공하기**
인터페이스 관련 문서 제공 방법 2가지
**1. 인터페이스 코드 안 주석**
**2. 별도의 문서 제공**
2 가지 모두하면 좋다.

내용은 구현이 아닌 동작에 초점을 맞춰 설명
ex. 입출력, 에러 종류, 처리법, 용도, 성능, 매개변수, 리턴 값 등


### **범용 인터페이스 디자인**

**하나의 기능을 다양한 방식으로 실행하게 만들기**
ex. Vector의 operator[] 나 at 메서드

**커스터마이즈 지원하기**
핵심기능을 제공하되 사용자에게 선택권을 줄 수 있는, 구현 범위를 넓힐 수 있도록 디자인


### **범용성과 사용성의 조화**
범용성을 높이려하면 사용성이 떨어지는 trade-off 관계 일 수도 있으나,
몇가지 디자인 원칙을 지키면 좋다.

**여러 가지 인터페이스 제공**
기능을 충분히 제공하는 동시에 인터페이스 복잡도를 낮추려면, 다양한 인터페이스 제공
= 인터페이스 분리 원칙(Interface Segregation Priciple, ISP)
ex. 제네릭 네트워킹 라이브러리의 인터페이스는 2가지
=> 게임 제작에 유용한 네트워킹, HTTP로 웹에 접근하는데 유용한 인터페이스

**자주 사용하는 기능 쉽게 만들기**
ex. 영어 사용자가 많으면, 영어가 default에 옵션을 변경할 수 있도록


### **SOLID 원칙**
![image](https://user-images.githubusercontent.com/85000118/137135297-3ad7284d-a167-4259-bcf6-147675cf2b03.png)



### 작성은 한 번, 사용은 여러 번
