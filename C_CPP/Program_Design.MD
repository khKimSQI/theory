프로그램 코드 작성하기 전에 반드시 프로그램 디자인부터 해야 함!
제대로 된 디자인은 구현, 디버깅, 유지보수 모든 점에서 좋다.

### **요구사항 분석**
프로젝트 시작 or 프로젝트 개선의 가장 첫 단계 ( 이해 당사자와 함께 논의 필요 )

이 단계의 가장 핵심적인 결과 = **기능 요구사항 문서**
=> **해야 할 일**만 표현하고, 구체적인 방법은 생략

**비기능 요구사항 문서**
=> 최종 결과로 동작이 아닌 속성을 표현 (ex. 보안 뛰어남, 확장성 높음, 일정 성능 만족 )

### **프로그램 or 소프트웨어 디자인**
앞의 기능 및 비기능 요구사항을 만족하는 프로그램 구현 구조에 대한 명세서
=> 디자인 = 구현 계획 정리 ( 보통 문서 형태로 작성 )

크게 2가지 부분으로 나뉨
![image](https://user-images.githubusercontent.com/85000118/136906657-b1c0dcaf-4493-41f5-a459-fb7b452a62d9.png)

디자인 문서는 보통 상호작용 + 클래스 계층을 보여주는 다이어그램이나 표로 구성
=> 대표적으로 UML Unified Modeling Language 통합 모델링 언어

예상치 못한 문제로 인한 디자인 변경 
=> 소프트웨어 공학 프로세스 (ex. 스크럼, 애자일 소프트웨어 개발 방법론 )
=> 스크럼에서는 스프린트(sprint)라는 순환 주기에 따라 애플리케이션 개발 과정을 반복함 ( 추후 설명 )

**디자인의 필요성**
=> 중간 중간 문제가 발생하였을 때, 땜질하듯이 대처하는 방법은 유지보수나 디버깅에 좋지 않다. 
=> 서비스시스템 사이의 관계, 재사용 또는 공유 정보 가능성, 작업 처리하기 위한 가장 쉬운 방법 등을 놓치기 쉽기 떄문

체스 Pawn  ( UML )
![image](https://user-images.githubusercontent.com/85000118/136914927-b63d1ed5-03f2-4fb7-910b-eb9d217014de.png)

체스 Bishop ( UML )
![image](https://user-images.githubusercontent.com/85000118/136915442-8f2aec3c-c51a-48c3-9ad2-8636a638dd69.png)

설계 전에 하나씩 구현하였다면, 각 체스 말에 공통점이 많다는 사실을 눈치채지 못하여 모두 구현하게 될 수 있음.
그리고 서브시스템 ( 체스판 )이 어떤식으로 동작하는지, 그래픽 기반인지 텍스트 기반인지에 따라 구현이 달라질 수 있음



### **C++ 적합한 디자인 방법**
C++ 언어의 특성
 - C언어 + 클래스,객체 + 연산자 오버로딩, 익셉션, 템플릿 등 다양한 기능
 - 객체지향 - 클래스 계층, 클래스 인터페이스, 객체 상호작용의 결정이 필요
 - 코드 범용성, 재사용성 - 상속, 연산자 오버로딩, 템플릿 등
 - 스트링 클래스, I/O 데이터 구조 알고리즘 라이브러리 제공
 - C++은 다양한 디자인 패턴이나 문제해결 기법 적용하기 좋음

디자인을 하다가 막힌다면??
1. 도움을 요청한다 - 동료나 멘토, 책 , 뉴스, 커뮤니티 등
2. 잠시 다른일을 우선 : 나중에 다시 디자인 작업
3. 일단 결정을 내리고 다음 단계
=> 차선책이라도 일단 그 방식으로 진행, 잘못됐다면 금세 드러나지만 해보면 의외로 좋은 방식일 수 있음
=> 그 결정을 내린 이유나 기타 내용을 문서로 남기면서 진행하면 좋다

### **C++디자인 두 가지 원칙**
핵심 원칙은 추상화(abstraction), 재사용(reuse) 이다.

### **추상화**
객체로 변환하는 과정이라고 볼 수 있다.
TV => 볼륨 변경, 채널 변경, ON/OFF와 같은 기능을 가진 하나의 객체
=> 내부 구현을 몰라도 외부 인터페이스 (기능)이 명확히 분리되어 있어, 인터페이스만 알아도 사용이 가능하다.

**1. 추상화의 장점**
내부 구현을 몰라도 코드 사용 가능 - 공개된 인터페이스만 사용하면 됨 ( ex. math의 sqrt()를 몰라도 사용 가능
**2. 추상화를 적 용하여 디자인**
함수 클래스 디자인은 타인이 내부 구현을 몰라도 사용할 수 있게 구성
=> 체스판을 8*8로 내부 지정하였다. => 사용자는 체스판이 8*8 2차원 배열인것을 알아야만 함 
=> 구현과 인터페이스가 완벽하게 분리되지 않았다.

![image](https://user-images.githubusercontent.com/85000118/136927090-ddd1373e-5461-48f5-b633-bf7f37ed7be4.png)
위 처럼 구현하면, 구현방식이 바뀌어도 인터페이스를 유지할 수 있다.
구현코드에 경계선 검사 같은 기능들도 추가 가능

### **재사용**
C++ 중요 원칙 재사용
기존 코드를 재사용 할 수 있다면, 이를 검토하여 수정하는 방식을 고려해야 한다.

**1. 재사용 가능한 코드 제작**
직접 작성한 코드, 가져다 쓰는 코드 모두 클래스, 알고리즘, 데이터 구조 등을 재사용 할 수 있도록 디자인 해야 한다.

C++은 코드 를 범용적으로 만드는 **템플릿** 기능 제공함

Template 예제 ( 추후 설명 )
```c++
template <typename PieceType>
class GameBoard
{
public:
//생성자 소멸자 대입 연산자 생략
  void setPieceAt(size_t x, size_t y, PieceType* piece);
  PieceType* getPieceAt(size_t x, size_t y);
  bool isEmpty(size_t x, size_t y) const;
private:
//데이터 멤버들
};
```
위 처럼 GameBoard라는 제네릭 템플릿으로 정의하고,
게임에 사용하는 말을 인터페이스에 고정시키지 말고 템플릿 매개변수로 전달하도록 클래스 선언을 변경
=> 이런식으로 인터페이스를 변경함으로써 2차원 보드를 사용하는 게임이라면 어디서나 적용할 수 있는 제네릭 게임보드 클래스 제작 가능

**2. 디자인 재사용**
많은 프로그래머들이 앞서 개발 또는 디자인한 패턴을 활용하지 않고 새로 진행하는 실수를 저지른다.

예를 들어,
객체 하나만 사용하는 클래스를 다른 서비스에서도 이용해야 하는 경우,
=> 의존성 주입(dependency injection)패턴으로 각 서비스에 맞는 인터페이스로 수정하여 주입해야 함


### **코드의 재사용**
표준 라이븡러리, 오픈소스, 회사에서 구매한 상용코드, 예전 프로젝트 등 다양한 코드를 적재적소에 활용할 수 있어야 하고,
그에 따른 장단점을 명확히 파악해야함
=> 단순히 복붙하는게 아닌, 일일히 복제하지 않아도 코드 재사용이 가능해야함

재사용 가능 코드의 구분
 - 자신이 작성했던 코드
 - 동료가 작성했던 코드
 - 서드파티에서 작성했던 코드

**용어 정리**
재사용할 코드를 만드는 형식
 - 독립함수 또는 클래스
자신 또는 동료가 작성한 코드는 대부분 이렇게 재사용
- 라이브러리
XML을 파싱하거나 암호화 등 특정 작업 처리에 필요한 코드를 묶은 것
 - 프레임워크
디자인할 프로그램의 기반이 되는 코드 모음 ( ex. MFC )
 - API (Application Programming Interface)
특정 기능을 수행하는 코드나 라이브러리에 대한 인터페이스 (ex. socket API)

**API <-> 라이브러리**
라이브러리는 구현을 의미하고, API는 이러한 라이브러리를 외부에 제공하기 위한 인터페이스
이 모든 것을 라이브러리라고 표현하기도 한다.


### **코드 재사용의 장점**
 **- 기본적인 기능은 표준 라이브러리를 이용하면 구현 불필요**
 **- 재사용 코드로 구현한 컴포넌트는 디자인 불필요 => 디자인 과정 간결**
 **- 재사용한 코드 디버깅 불필요**
 **- 라이브러리는 대부분 다양한 에러 상황 대응하도록 작성됨**
 **- 라이브러리는 비정상적인 입력에 대해 대부분 적절한 대처가 가능함**
 **- 해당 분야 전문가 작성 코드가 훨씬 안전함**
 **- 라이브러리는 지속적으로 개선됨**

### **코드 재사용의 단점**
 **- 타인 작성 코드는 학습시간 필요**
 **- 원하는 동작과 정확하게 일치하지 않을 수 있음**
 **- 원하는 만큼의 성능이 나오지 않을 수 있음**
 **- 유지보수에 문제 발생 가능성 있음 => 문제가 있어도 직접 수정할 수 없음 (보통 API를 가져다 쓰기 때문)**
 **- 라이선스 문제 발생 가능성**
 **- 크로스 플랫폼 호환성 문제 발생 가능성**
 **- 재사용할 코드의 신뢰 필요**
 **- 라이브러리 업그레이드로 인한 문제 발생 가능성**
 **- 컴파일러와 라이브러리 간 호환 문제**

### **재사용 코드 고려사항**
**1. 기능과 제약사항 파악**
가이드 라인
** - 멀티 스레드 사용 가능여부**
** - 컴파일러에 특수 설정이 필요한가??**
** - 초기화나 종료 시, 수행할 작업이 있는가?**
** - 라이브러리가 의존하는 라이브러리가 있는가**
** - 상속할 때, 어떤 생성자를 써야하고 오버라이드 해야하는지**
** - 메모리 할당과 해제 주체 확인, 스마트 포인터 사용가능 여부**
** - 라이브러리 에러 조건이나 상황 가정 => 에러 팝업 or stderr/cerr나 std/out/cout으로 전달 or 프로그램 종료는 피한다**
** - 함수 리턴 값이나 레퍼런스 파악**
** - 함수에서 발생하는 익셉션들 파악**

**2. 성능 파악**
알고리즘 complexity - 빅오 표기법 사용
![image](https://user-images.githubusercontent.com/85000118/136942607-a928b828-4ceb-48e0-bd36-985bb49e39be.png)

빅오 표기법으로 표현한 성능과 실제 성능은 다를 수 있음 ( 입력 크기나 IO 점근 표기법 등 )

**90/10 법칙** => 프로그램 실행시간의 90%는 코드의 10%가 차지함
= 시간을 많이 소요하는 코드를 주의깊게 체크

문서를 너무 믿지말고 스스로 사용해보고 판단해야 한다.

**3. 플랫폼 제약사항 파악**
OS 종류나 버전에 따른 차이 체크

**4. 라이선스 기술 지원 파악**
 - 라이선스 비용 지불 가능성
 - 기술지원 문제
 - 버그 리포트 절차 & 버그 수정 완료까지 걸리는 시간
 - 언제까지 지원 하는 지
**특히 배포 및 판매 목적의 개발 프로그램에선 라이선스 체크가 중요**

**5. 도움을 받을 수 있는 곳 파악**
웹이나 책 등 다양한 경로

**6. 프로토 타입**
라이브러리나 프레임워크 첫 사용에 간단한 프로토 타입 구현해보기 => 직접 짜보면 많은 도움이 됨
( 시간이 소요되더라도 기능 파악에 많은 도움이 됨 + 실제로 시간 문제로 프로토 타입이 최종 결과물에 반영될 수 있음 )

**서드 파티 애플리케이션을 통째로 사용하기도 한다.** 
=> 라이브러리와 동일하게 라이선스 문제나 기타 제약사항 확인 필요

### **오픈 소스 라이브러리**
Open source 누구나 들여다 볼 수 있는 코드 or OS 등

 - 자유 소프트웨어 ( free software )
코드 수정, 재배포, 상업 목적 모두 자유
 - 오픈소스 소프트웨어 ( by Open Source Initiative )
반드시 무료일 필요 없음 => But, 수정하고 재배포할 자유를 반드시 보장할 필요가 없다.
 - GPL (GNU Public License)
GPL 라이브러리 사용 => 결과물도 GPL 라이선스 ( 소스코드 공개 )

그 외 부스트 소프트웨어 라이센스, BSD, 코드 프로젝트 오픈 라이선스, 크리에이트 커먼즈 등을 따르는 오픈소스 라이브러리는
최종 제품은 코드를 제공하지 않아도 됨

이러한 사항들을 고려하여 라이브러리를 선택해야 함
추가로, 오픈소스는 책임자가 없을 수 있어 유지보수가 진행되지 않을 수 있음
