### **절차형 사고방식**
C언어의 Procedural Programming 절차형 프로그래밍 관점을 먼저 설명

절차형 언어
=> 하나의 작업만 담당하는 프로시저라 부르는 작은 단위로 코드 구성 (함수라고 보면 됨)
프로시저가 없으면 main 함수에 모두 넣어 가독성이 떨어지고 협업히 힘들어짐

Procedure프로시저는 일종의 추상화 기법으로 여러 사람이 코드 읽기 쉽게 만들어줌
**이 프로그램이 무슨 일을 하는가?**
위 질문을 바탕으로 발전된 개념이 프로시저
프로그램이 하는 일을 순서대로 나타내며 절차적으로 생각하는 방식

C언어의 프로시저를 함수라고 하지만, 함수형 언어는 아님
=> 절차형 언어 <-> 함수형 언어

일정한 단계에 따라 진행하는 프로그램
=> 절차형 접근 방식 적합

절차형 <-> 객체지향
**이 프로그램이 무슨 일을 하는가?** <- > **현실세계의 어떤 대상을 모델링하는가?**
=> 물리적인 대상을 **클래스, 컴포넌트, 프로퍼티(속성), 동작** 관점에서 분석 필요

### **클래스**
어떤 대상의 유형을 정의하는 속성을 정리한 것 = 클래스  ( 오렌지 - 나무에서 자람, 주황색, 독특한 향과 맛, 과일 등등 )
특정 구체적인 대상 = 객체 ( 냉장고에 있는 오렌지 하나 ) => 특정 클래스에 속한 Instance
=> 같은 클래스여도 서로 구분됨

### **컴포넌트**
부품으로 본질은 클래스와 같지만, 조금 더 작고 세분화한 단위
ex.) 비행기 => 랜딩기어 => 바퀴

### **프로퍼티(속성)**
객체는 속성으로 구분
=> 객체 구성 프로퍼티는 같지만, 값은 다르다 ( ex. 맛이 좋을수도 좋지 않을수도 있다 )

### **동작**
동작(behavior)은 객체가 하는 일, 객체로 할 수 있는 일을 표현
ex. 오렌지 먹기, 굴리면 둥근 오렌지와 납작한 오렌지 동작이 다름
ex. 주식의 분석 동작
=> OOP에서는 기능을 수행하는 코드를 프로시저가 아닌 클래스 단위로 묶음
클래스 메서드class Method

### **중간 정리**
주식 종목 추천 프로그램 예시

Class(주식 시세 컬렉션) => Class-Component(주식 시세)
최소 하나의 Property(시세목록)    =>  회사 이름, 종목 번호 등의 Property + 분석 behavior
![image](https://user-images.githubusercontent.com/85000118/137048871-207ce37b-9c63-4fbb-9f6d-d511cd0c156a.png)

오렌지를 대상으로 UML 다이어그램
![image](https://user-images.githubusercontent.com/85000118/137048888-79a28f3f-5664-4f70-864d-dcf84f58081d.png)


### **객체 관점에서 바라보기**
객체 관점 개발에 적용 가능한 접근 방식
**1. 객체 = 단순히 데이터 + 기능으로 여기고 프로그램 전반에 걸쳐 사용해 가독성과 유지보수성 높이기**
=> 코드에서 독립된 부분 골라내어 객체 전환 
**2. OOP 패러다임 완벽히 적용하여 모든 것을 객체로 표현

가장 바람직한 방법
=> 적절하게 조합하여 객체로 표현

### **과도한 객체화**
창의적 디자인 <-> 사소한 것까지 객체화
=> 기능도 관련된 컴포넌트도 없는 프로퍼티만 갖는 객체를 만들 필요가 있는가

### **지나친 일반화**
과도한 객체화보다 나쁠 수 있다.
미디어 파일을 정리하는 프로그램이 => 모든 파일을 미디어 파일 객체로 생각하고 처리
=> 하나의 클래스로 모든 것이 표현되는 상황



### **객체 관계**
객체들을 공통 분모가 있을 수 있다.
이러한 관계를 표현하기 위한 has-a, is-a가 있음

### **has-a**
A는 B를 가진다 or A에 B가 있다
=> has-a 관계(포함, 소유 관계) or 집합(aggregation) 관계
한 객체가 다른 객체의 일부인 케이스
ex. 동물원 - 원숭이

![image](https://user-images.githubusercontent.com/85000118/137049846-883ac149-15c2-402b-aabd-ebb62420e5d1.png)


### **is-a 관계**
is-a 관계는 OOP 상속(inheritance)에 관한 것
=> 상속 = 파생, 서브클래싱, 확장 등 다양한 표현
=> A는 일종의 B다 , A는 정말 B를 상당히 많이 닮았다.

![image](https://user-images.githubusercontent.com/85000118/137050067-979943d0-bd17-40ef-9922-51c0b95c9cd1.png)
Animal에 대한 파생클래스로 아래 클래스들을 만든다.

공통 기능을 가진  Base Class (상위 클래스)로 묶어서 확장 가능한 구현



### **상속 기법**
부모 클래스(Parent Class) = 상위 클래스, 베이스클래스, 슈퍼클래스로부터 파생

1. 기능 추가
파생 클래스는 기능을 추가해 부모 클래스 보완
2. 기능 변경
부모 클래스가 가진 메서드를 변경하거나 무시(Ovveride) 가능함
3. 프로퍼티 추가
베이크 클래스를 상속한 파생 클래스에 새로운 프로퍼티 추가 가능
4. 프로퍼티 변경
메서드 오버라이드처럼 프로퍼티도 오버라이드 가능
=> 공통 속성을 변경하는 것은 바람직하지 않을 수 있음

### **다형성 & 코드 재사용**
다형성(폴리모피즘 Polymophism)
=> 프로퍼티와 메서드의 표준 셋으로 정해두면 그 형식에 맞는 객체라면 어느 것이든 바꿔서 적용 가능하다는 개념
== 모든 Monkey객체는 Monkey 클래스에 정의된 프로퍼티와 메서드를 반드시 제공
ex. Animal => Monkey => Monkey Instance

다형성은 모든 파생 객체들에 대해서 ex. move 함수를 수행할 때 종료 따질 필요 없이 Move 메서드만 수행하면 됨

그리고, 상속을 통해 코드 재사용이 원활해짐
ex.) 에코 음악 재생기 개발을 위해 기존에 개발된 음악 재생기를 상속 받으면 개발 필요가 없음

### **is-a, has-a 구분**
UML로 비교하면
**is-a**
![image](https://user-images.githubusercontent.com/85000118/137052469-5e708eea-f0b5-4498-9c71-0a587eb6e37b.png)

**has-a**
![image](https://user-images.githubusercontent.com/85000118/137052590-72cbb25e-2c31-4547-b623-f9d3cd27e36f.png)


![image](https://user-images.githubusercontent.com/85000118/137053484-d057eb21-1f78-4e9b-9ec0-1ebb835d371e.png)

LSP (리스코프 치환 원칙)을 따라 has-a로..

여러 경험에 비추어 선택한다면 has-a가 좋다.

### **Not-a관계**
객체지향은 기능 관점에서 관계를 표현해야 함
![image](https://user-images.githubusercontent.com/85000118/137053692-407d636e-b1d2-4d66-936f-a1e167767d3a.png)

메서드를 갖지 않는 클래스가 있거나,
파생 클래스에서 모두 오버라이드 한다면 디자인을 바꾸는 것이 좋다.

### **클래스 계층**
파생 클래스 디자인
![image](https://user-images.githubusercontent.com/85000118/137053976-95452d3c-fa1e-41f9-b87d-eea3bc071b1b.png)

세분화한 계층
![image](https://user-images.githubusercontent.com/85000118/137054034-99997a77-2fb6-480a-8cbe-9a883f08f7ef.png)

관점에 따라 계층을 다르게 구성할 수 있음 ( ex. 먹이, 종류, 이동 방식 등 )
=> 구체적인 요구사항에 따라 객체지향 계층을 디자인

**제대로 구성된 객체지향 계층 특성**
![image](https://user-images.githubusercontent.com/85000118/137054181-952e16b8-f636-4552-a1df-4acace7d8aff.png)

### **다중 상속**
![image](https://user-images.githubusercontent.com/85000118/137054215-34850fb1-fc1e-4623-afcf-d105463a3dcc.png)
![image](https://user-images.githubusercontent.com/85000118/137054230-d5b54c84-e7a7-4c7c-baf5-9e26b7b98af6.png)

C++
다중상속 직접 지원
Java
인터페이스와 추상 베이스 클래스에 대해서만 다중 상속 지원

다중상속을 반대하는 측의 이유
**1. 다중 상속 관계는 시각적으로 표현하기 복잡함
=> 프로그래머가 쉽게 이해해야 하는 점을 해침
**2. 다중 상속 떄문에 구조의 명확성이 깨질 수 있음**
=> 베이스 클래스의 역할이 줄어들고, 객체에 대한 코드가 여러 갈래로 갈라짐
**3. 다중 상속은 구현하기 힘듦**


### **믹스인(첨가) 클래스**
is-a 관계를 완전히 구현하지 않고, 기능을 추가할 때 사용
=> 일종의 공유 관계
믹스인 <-> 베이스
=> 제한된 용도라서 이해하기 쉬움 ( ex. 메서드 한두개만 구현 => Clickable (클릭가능))


### **추상화**
**핵심 = 인터페이스와 구현을 분리**
작업 달성을 위한 코드 <-> 가져다 사용하기 위한 수단

### **외부에 공개할 인터페이스 결정**
private을 제외한 public, protected 접근 제한(지정)자를 결정해야 함

**사용자 고려**
외부 인터페이스 사용자가 누구인지, 회사인지, 외부 소속인지 등을 고려해야 함

**용도 고려하기**
사용 목적 확실하게 파악해야 함
**1. API**
=> 가장 고민할 사항 : 사용성과 유연성의 절충점
=> 잘만든 API = 쉬운 일은 쉽게 복잡한 일은 가능하게
**2. 유틸리티 클래스 | 라이브러리**
=> 범용적으로 사용할 수 있도록 범용성을 핵심적으로 고려
**3. 서브시스템 인터페이스**
=> 핵심 목적을 분명히 하는 것
**4. 컴포넌트 인터페이스**
=> 다른 이들이 사용한다는 생각으로 디자인 필요

### **미래 고려하기**
나중에 사용할 것을 염두에 두고 디자인 해야 함

핵심 :
 - 추상화 잘된 인터페이스는 Public 메서드로만 구성
 - 계층 구조가 너무 깊으면 보조할 다른 클래스 도입도 좋음
 - 프로퍼티는 모두 메서드로(게터, 세터)
 - 반복하여 조언을 구하고 반영하고
