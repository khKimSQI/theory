### **체스 프로그램 디자인**

먼저, 요구 사항을 명확히 정리 (**요구사항 명세서 - requirement specification**) 문서 형태로 정리하는 것이 가장 바람직

가상의 대략적인 요구사항 ( 실제는 더 구체적이고 다양하게 작성 필요 )
 - 표준 체스 규칙을 준수
 - 두 명의 플레이어를 지원, 컴퓨터가 조작하는 플레이어 제공 X
 - 인터페이스는 텍스트 기반
* 체스보드 & 말은 일반텍스트 표현
* 플레이어는 체스보드의 위치를 숫자로 입력하여 말을 움직임

위 요구사항을 준수하는 프로그램 디자인이 필요하다.

### **디자인 단계**
일반적인 부분에서 시작 => 구체적인 부분
필요하다면 다이어그램 표도 작성함 ( 산업 표준으로 UML이 있음 )
=> UML은 클래스 다이어그램, 시퀀스 다이어그램을 비롯한 소프트웨어 디자인을 문서화 하는데 사용할 수 있는 다이어그램을 표준화 한 것

### **프로그램을 서브 시스템으로 분할**
 - 기능에 따라 서브시스템 단위로 분할, 
 - 각각에 대한 인터페이스와 연동방식 정의
=> 데이터 구조나 알고리즘, 클래스에 대해서는 신경쓰지 않음 (프로그램 전반적인 구성과 각 요소의 연동방식 구상에 집중)
=> 하이레벨 관점에서 동작, 기능, 다른 서브시스템에 제공할 인터페이스, 다른 시스템 사용에 필요한 인터페이스 등을 정리

본 체스 프로그램에서는 Model-view-controller MVC 패러다임을 적용
=> 데이터 저장, 표시, 조작을 나눠서 각각의 모델로 만듬
=> 데이터 집합(Model), 시각적 표현(View), 이벤트에 따라 모델 조작(Controller)

MVC = 루프백 기반 연동
Action => Controller 처리 => Model 조작 => View 반영 

![image](https://user-images.githubusercontent.com/85000118/136949717-e165cf32-0ba4-4fb1-bf79-1acb8f76f7b3.png)
모델 예시 자료

설계 방법은 다양하지만 공통적으로 적용하는 올바른 방법
=> 잘 구성하면 기본 기능에 따라 분리가 가능함 ( Player + GamePlay를 합치면 논리적으로 구분되지 않음 )

M : ChessBoard, ChessPiece
V : ChessBoardView, ChessPieceView
C : Player

![image](https://user-images.githubusercontent.com/85000118/136957357-063f7e0f-218e-43b7-8d23-1aaf68390956.png)

서브 시스템 간의 관계를 표로 표현하기 힘들면 선을 이용하면 쉬워진다.

다음으로 
### **스레드모델 선택하기**
세부적인 스레드는 디자인 단계에서 고려할 필요는 없지만,
프로그램 최상위에서 사용할 스레드 수나 상호 작용 방식정도는 정해두는 것이 좋음

최상위 스레드
=> ex. UI 스레드, 오디오 재생, 네트워크 통신 스레드 등

멀티 스레드 구현할 때는 **공유 부분 최소화**해야 간결성과 안전성 측면이 좋다.
굳이 스레드를 사용하고 공유해야 한다면 Mutex(Lock)방식을 정함

본 구현은 싱글스레드로 충분하다.

### **서브시스템의 클래스 계층 구성**
추상 베이스 클래스와 아랫단의 계층 정하기
![image](https://user-images.githubusercontent.com/85000118/136962434-c1f6e59f-5f9d-4b0a-9dc3-dfc283e634c2.png)
자바로 치면 Interface고려하기 ( 추상 베이스 클래스 )

텍스트 기반, 그래픽 기반 인터페이스도 고려한다면 BoardView도 계층을 정해야 한다.
![image](https://user-images.githubusercontent.com/85000118/136962596-7e6bb4d4-7873-4564-a9d1-5e262cf77376.png)

자세한 디자인 방법은 추후 설명

### **서브시스템 클래스, 데이터 구조, 알고리즘, 패턴 지정**
각 서브시스템 세부 사항을 지정하는 단계

![image](https://user-images.githubusercontent.com/85000118/136962760-a019a346-4142-4b28-b757-a553f46df9f1.png)

위 사항들을 적용하는 과정은 간단하지 않다.
추상화 및 재사용성 원칙을 최대한 적용 필요
**추상화의 핵심 : 인터페이스와 구현을 따로 구분**
=> 컴포넌트가 할일 지정 후, 적절한 데이터 구조와 알고리즘을 선택하여 일처리 하는 방법 결정

**재사용성**을 높이기 위해 사용했던 구조, 알고리즘, 패턴 등을 잘 익혀둘 필요가 있음

### **에러 처리 방법 정하기**
각 서브시스템 에러처리 방법 규정
Error Handling 방식을 정할 땐
 **- 메모리 할당 오류같은 시스템 에러**
 **- 잘못된 입력같은 사용자 에러**
모두 고려하고, 각 서브시스템 exception 사용 여부도 지정

![image](https://user-images.githubusercontent.com/85000118/136963708-2a730e47-2094-4644-8934-058b5bd7b8f1.png)
기본 원칙 : 모든 에러를 처리하기
=> 모든 가능성 따져보기
