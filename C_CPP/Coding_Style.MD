개인마다 코드 작성 기준이 다르기 떄문에 명확하진 않지만, 주로 공통되는 필요한 작성 스타일
 - 문서화
 - 분할
 - 명명 규칙
 - 언어 사용
 - 포매팅

### **문서화**
documentation이란 주로 주석을 의미함

1. 사용법을 알려주기 위함
 - public 메서드는 반드시 주석을 달거나
 - 메서드 목적, 인수, 리턴 값, 익셉션 등에 따라 달거나
 - 가능하다면, 타입으로 구체화 시키는 것도 좋다 ex. int => RecordID
 - Exception은 꼭 명시하는 것이 좋다.
 - 형변환 해야하는 정보나 그런 것도 좋다.
2. 코드의 알고리즘 설명
 - 이해하기 어렵고 난해한 코드에 대한 설명
 - 불변 속성(invariant) - 일정한 코드 수행에 반드시 만족하는 조건
3. 메타 정보 제공 ( Meta-onformation)
 - 코드 내용과 다른 차원의 정보 제공 목적
 - ex. 작성일, 작성자, 기능 or 버전, 특정 버그 개선사항, 변경 내역, 추후 넣어야 하는 사항 등
 - 꼭 필요한 것이 아니면 git이나 svn처럼 소스 코드 관리 솔루션을 이용
 - 저작권 정보 포함하기도 함
 - 협업하는 팀과 상의하며 결정하는게 좋다.

### **주석 스타일**
1. 문장 단위 주석
 - 각 문장마다 // 형태로 주석 다는 것
 - 불필요하거나 쉬운 정보도 쓰면 지저분해보일 수 있음
![image](https://user-images.githubusercontent.com/85000118/136878420-70c9ef9e-4dfa-4103-8632-0280b1fff6d5.png)
일부분만 표현된 위 코드의 경우, 바람직하게  구체적으로 코드를 설명하고 있다.
2. 머리말 주석
 - 소스코드 첫머리에 파일 관련 주요 내용 기입(초기 템플릿 입력해주는 개발 환경도 있음)
 - 최초 수정일자 *
 - 최초 작성자 *
 - 변경 내역 *
 - 파일에서 구현한 기능의 ID
 - 저작권 정보
 - 파일/클래스 간략한 설명
 - 미완성 기능
 - 발견된 버그
* 는 대부분의 소스 코드 관리 시스템에서 자동으로 달아줌
서브버전(SVN) 을 비롯한 몇몇 관리 시스템은 $id$ 같은 스트링에 정보를 적어주기도 한다.
3. 고정 양식 주석
외부 문서화 도구로 표준양식을 이용한 작성 사례가 늘고 있다.
 - 자바 프로그래머는 JavaDoc 표준양식
 - C++은 HTML, 클래스 다이어그램, 유닉스 Man Page를 비롯한 여러 유용한 문서를 자동으로 생성해주는 Doxygen 무료툴 많이 사용
![image](https://user-images.githubusercontent.com/85000118/136881731-4c5fe626-34a5-4424-81f0-df911f0ef691.png)
![image](https://user-images.githubusercontent.com/85000118/136881932-093a8f0f-a17e-4f53-b115-b50053c1b426.png)
Doxygen 생성

4. 임의 주석
 - 정해진 양식 없이 써야 할 때  아래와 같은 가이드라인
 - 공격적이거나 무시 표현 삼가
 - 팀원끼리의 농담은 관리자 검토 필요
 - 주석을 작성 전, 주석이 필요 없도록 코드 수정이 가능한지 검토 ex. 코드 처리순서, 이름 변경 등
 - 남이 읽는다는 생각으로 이해하기 힘든 부분 주석
 - 자기 이름을 남기지 않음
 - API사용 과정이 명확하지 않으면 참고문헌
 - 코드를 업데이트할 때 반드시 주석도 함께 업데이트
 - 한 함수를 여러 부분으로 나누기 위해 주석을 작성할 떄 그 함수를 더 작은 단위로 나눌 수 있는지 검토

5. 주석이 필요 없는 코드
 - 잘 작성된 코드는 주석이 없어도 읽기 쉽다.
 - 이름은 그 역할이 잘 드러나도록
 - 수정 방지를 위해 const 사용
 - 작업 처리 순서도 내부 과정이 명확히 드러나도록 수정
 - 코드를 작은 단위로 분할하면 주석을 안써도 될 수 있음


### **코드 분할**
함수나 메서드는 한가지 역할만 하도록 작성하는게 좋다. 
=> A, B를 순차 실행하고 C 조건 만족 시, D수행 아니면 E 수행이라는 식이면 A,B,C,D,E 각각의 메서드를 분리하는게 좋다.

### **리팩토링 코드 분할**
Refactoring 이란 코드의 구조를 재조정하는 작업
1. 추상화 수준 높이기
 - 필드 캡슐화 : 필드를 private 설정하고, getter나 setter로 접근
 - 타입 일반화 : 코드를 좀 더 공유할 수 있도록 좀 더 일반적인 타입 사용
2. 코드를 논리적으로 분할하기
 - 메서드 추출 : 거대한 메서드를 이해하기 쉽게 일부를 뽑아내 새로운 메서드로 정의
 - 클래스 추출 : 기존 클래스에 있는 코드 중 일부를 새 클래스로 옮김
3. 명칭과 위치 개선하기
 - 메서드 및 필드 이동 : 적합한 클래스나 소스 파일로 이동
 - 메서드 및 필드 이름 변경 : 목적이 잘 드러나도록 이름 변경
 - 올리기(상향,풀업,pull up) : OOP에서 기본 (base) 클래스로 옮기는기법
 - 내리기(하향,푸시다운,push down) : OOP에서 상속(확장,derived) 클래스로 옮기는 기법

테스트 프레임 워크를 활용하여 리팩토링 과정에서 발생하는 버그 찾기 ( 추후 설명 )

**디자인 기준 분할**
시작부터 모든 기능을 구현하기 보다는, 프로그램 디자인 후에, 나중에 모듈, 메서드, 함수에서 구현할 부분을 빼놓는 방식으로 하면 밀집도를 낮추고 체계적으로 가능

### **명명 규칙**
C++ 컴파일러 명명 규칙
 - 이름의 첫글자는 숫자 불가
 - 더블 언더스코어는 특정 용도로 사용 (ex. my__name)
 - 언더스코어 시작 이름도 특정 용도 (ex. _name)
이 외에도 다양한 규칙이 존재함

![image](https://user-images.githubusercontent.com/85000118/136889383-7d791691-c678-4775-bfd7-6e17371c6433.png)

### **명명 관례**
**1. 카운터**
카운터 변수 i나 j는 실수를 저지를 수 있음
2D 데이터를 다룬다면 행과 열에 row, column을 사용하면 좋다.
outerLoopIndex, innerLoopIndex 식으로 사용하는 프로그래머도 있고, 프로그래머마다 차이가 있음

**2. 접두어**
변수 이름 앞에 타입이나 용도를 암시하는 문자
![image](https://user-images.githubusercontent.com/85000118/136890252-e7406e20-4ef6-465d-bffa-35561fe49374.png)
회사나 사람마다 규칙이 다르기도 함 ( 수정은 불편하지만 구분에는 용이함 )

**3. 헝가리안 표기법**
Hungarian Notation MS 윈도우 프로그래머가 변수와 데이터 멤버에 주로 적용하던 규칙
표기법을 만든 찰스 시모니가 헝가리 사람
```c++
char* pszName; // pointer string zero = null로 끝나는 문자열 포인터
```

**4. 게터 & 세터**
데이터 멤버 접근에는 주로 사용 ( bool은 get 대신 is를 붙이기도 함 ex. isRunning)
C++ 언어의 메서드 명명규칙은 아니지만, 팀 단위에서는 사용할 필요가 있음

**5. 대소문자 활용**
 - 소문자 + 언더스코어 방식 ( priority_queue )
 - 단어의 첫글자 대문자 (Priority_Queue) - 지저분해짐
 - 소문자 시작, 단어 첫글자 대문자 ( priorityQueue )
 보통은 첫번째나 세번째를 많이 사용함

**6. 네임스페이스 적용 상수**
상수 사용에서 konstant를 이용한 kHelp 같은 방식을 이용하기도 하지만,
비슷한 이름의 기능을 다른 곳에서 사용 (ex. 메인 - Help, 서브 -Help) 한다면 중복된다.
이럴 경우, 서로 다른 네임스페이스에 속하게 제작한다.
Main::kHelp, Sub::kHelp

### **언어 기능에 스타일 적용하기**
컴파일러는 가독성이 나쁜 코드도 허용한다.
=> i++ + ++i;    , a[i] = ++i;
2번째 코드의 경우 C++17에서는 i값을 증가시키고 해당 index를 사용함, 하지만 컴파일러마다 다를 수 있음

**1. 상수 사용법**
특정 고정된 숫자는 상수를 사용하여 표기함
ex. ) const double kApproximationForE = 2.71828182845904523536;  => 초월수 e의 근삿값

**2. 포인터 대신 레퍼런스 사용하기**
1. 레퍼런스는 메모리주소를 직접 다루지 않고 nullptr가 될 수 없다.
2. 지역변수와 문법이 같아서 별도로 &나 *를 사용할 필요가 없다.
3. 소유권을 명확히 할 수 있음. 레퍼런스로 전달한 객체 메모리를 해제하기 쉽지 않음

**3. 사용자 정의 exception**
C++에서 익셉션 처리에 대한 규칙이 없고 기존 방식으로 대처할 수 있어 무시하기 쉽다.
하지만, 에러 처리 관련 기능을 풍부하게 제공해줌
직접 정의하는 기능도 있다. ( 추후 자세한 설명 )

### **포매팅(formatting)**
개인마다 다른 코드 서식 - 사전에 팀원이나 부서원가 정리 필요함

**1. 중괄호 정렬**
```c++
if(condition()){
   // 방식 1
}

if(condition())
{
   // 방식 2
}

if(condition())
     {
          // 방식 3- 가로로 더 넓게 씀
     }

if(condition())
       // 방식 4 - 한 문장은 중괄호 필요 없다.

```
위 처럼 다양한 방식이 있는데, 사전에 조율이 필요할 수 있다.

**2. 공백과 소괄호**
우선순위 구분 필요가 없을 때, 괄호를 쳐야하는가?
연산자나 각 변수, 상수를 띄어서 써야하는가?

선호도나 규칙에 따라 정해야 함 ( 개인적으로는 visual studio 처럼 자동 정리 기능 따르는 것도 좋아보임 )

**3. 공백과 탭**
탭이 몇개의 공백으로 되어 있는지,
누구는 탭을 사용하고 누구는 스페이스바를 사용하면 문제가 될 수 있음

**중요 결론**
- 변경 불가 변수나 매개변수는 반드시 Const
- 변수 이름은 항상 명확하고 간결하고 이해하기 쉽게
- 왼쪽 중괄호를 다음줄에 쓰기
- 표준 텍스트 에디터를 정해서 여기에 탭과 스페이스에 대한 규칙 적용하기

포매팅 도구를 잘 활용하는 것도 강제 규칙적용에 좋다.
